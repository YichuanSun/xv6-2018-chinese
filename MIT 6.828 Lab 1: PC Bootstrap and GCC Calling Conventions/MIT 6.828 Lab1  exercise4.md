# exercise 1.4

作业写到现在，把这门课和coursera上吴恩达的机器学习放在一起，与国内的课程对比，发现国外的课程和国内相比，有很大差别。差别如下：

- 国内重课堂讲授，国外课程讲授很少，只有短短的录播课或者想这门课直接没有视频，关键在于课堂外文章资料的自行阅读和研究实践
- 国内研究性学习的效果不好。比如同样是课堂实验或者大报告，老师只会说“有兴趣的同学做一下”或者硬性要求要调研不少于多少篇SCI，其实学生要么不做，要么就随便拿几篇自己都没读过的SCI凑数，根本达不到研究的目的。而国外研究性学习会达到与期末考试同等甚至更高的地位，并且强制每个人都得做（不做必挂，不认真必挂），所以虽然我校一直都把研究性学习当做一个重点，但始终得不到好效果，老师都是睁只眼闭只眼，都打上不低的分数，糊弄糊弄就过去了，还是在期末考试见真章。

练习4要求阅读《The C Programming Language》chapter 5.1～5.5. 官方链接只对于mit学生开放。我恰巧两年前买了这本书的英文原版，但一不小心被水泡坏了，结果扔家里两年没看（还能阅读但是颜值已经很低>_<），结果这次疫情搞得，好书全留在学校了没在家，巧了这本被泡烂了的书搁在家里，被我找出来了，遂一口气看完了要求的全部5个小节。

-----

**要求：**详细阅读参考书目5.1~5.5节。能够理解从官网上下载的代码，并理解每个运行结果出现的原因。

下面是官网代码，一个很简单的C程序。

```C
#include <stdio.h>
#include <stdlib.h>

void
f(void)
{
    int a[4];
    int *b = malloc(16);
    int *c;
    int i;

    printf("1: a = %p, b = %p, c = %p\n", a, b, c);

    c = a;
    for (i = 0; i < 4; i++)
	a[i] = 100 + i;
    c[0] = 200;
    printf("2: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n",
	   a[0], a[1], a[2], a[3]);

    c[1] = 300;
    *(c + 2) = 301;
    3[c] = 302;
    printf("3: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n",
	   a[0], a[1], a[2], a[3]);

    c = c + 1;
    *c = 400;
    printf("4: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n",
	   a[0], a[1], a[2], a[3]);

    c = (int *) ((char *) c + 1);
    *c = 500;
    printf("5: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n",
	   a[0], a[1], a[2], a[3]);

    b = (int *) a + 1;
    c = (int *) ((char *) a + 1);
    printf("6: a = %p, b = %p, c = %p\n", a, b, c);
}

int
main(int ac, char **av)
{
    f();
    return 0;
}
```

运行结果

> 1: a = 0x7ffe093822c0, b = 0xc22010, c = 0xf0b5ff
> 2: a[0] = 200, a[1] = 101, a[2] = 102, a[3] = 103
> 3: a[0] = 200, a[1] = 300, a[2] = 301, a[3] = 302
> 4: a[0] = 200, a[1] = 400, a[2] = 301, a[3] = 302
> 5: a[0] = 200, a[1] = 128144, a[2] = 256, a[3] = 302
> 6: a = 0x7ffe093822c0, b = 0x7ffe093822c4, c = 0x7ffe093822c1

这有必要分析一下，尤其是line 5.下面的行号是指运行结果的行号。

输出始终用数组首址a作为起始地址，而不是指针b和c，所以输出元素的物理地址始终不变。

- line 1：显示a，b，c的地址，由定义可知，a是数组首址，b、是指针。数组首址是常量，不可改变，b和c是变量，所以虽然数组首址和指针都能表示地址，却存放在程序段的不同位置（从地址可看出，a相对于bc，存放的段不同）。
- line 2：把a赋给c。a表示数组首址，则指针c可以用来访问数组a了。输出比较容易。
- line 3：代码中使用了三种不同的寻址格式。对于第二种，*(c + 2) = 301，这是c[2]=301的编译预处理之后的格式，比c[2]=301这样写运行更快；对于第三种，这是个很有趣的写法，符合语法，相当于c[3]=302
- line 4 ：将指针c向后移了一个int单位，相当于后移4字节。
- line 5：注意这句话。

```C
c = (int *) ((char *) c + 1);
```

按运算符顺序，先把c强转为char型指针，注意，char型变量只占1字节，而int型变量占4字节。所以之后的+1只向前移动了1字节，之后再强转为int型指针。为了说明这个问题，请看下面的表格

| a[0] | a[1]                          | a[2]                          | a[3] |
| ---- | ----------------------------- | ----------------------------- | ---- |
| XXXX | X<font color="red">XXX</font> | <font color="red">X</font>XXX | XXXX |

每个X相当于1字节。在上述过程开始时，c指向a[1]，强转后，指向a[1]的第一个字节，再加1，指向a[1]的第二个字节，强转int，则指向从当前内存地址开始的四个字节，就是图中红色的字节，将这作为一整个int型数据格式，改为500，则破坏了a1和a2，就出现了原先的结果。

- line 6：讲真我第一次看没看懂line 5是怎么出来的，看了line 6才发现。观察三个变量的地址变化，可以看到c和a差1，b和a差4，单位都是字节，这就明白出错原因了。















